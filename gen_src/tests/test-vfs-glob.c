/* test-vfs-glob.c generated by valac 0.10.4, the Vala compiler
 * generated from test-vfs-glob.vala, do not modify */

/*
 * Desktop Agnostic Library: glob() wrapper test.
 *
 * Copyright (C) 2009 Mark Lee <libdesktop-agnostic@lazymalevolence.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA.
 *
 * Author : Mark Lee <libdesktop-agnostic@lazymalevolence.com>
 */

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <libdesktop-agnostic/vfs.h>
#include <stdio.h>

#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))



gint _vala_main (char** args, int args_length1);



gint _vala_main (char** args, int args_length1) {
	gint result = 0;
	DesktopAgnosticVFSGlob* g;
	gboolean first_arg;
	GError * _inner_error_ = NULL;
	if (args_length1 < 2) {
		result = 0;
		return result;
	}
	g = NULL;
	first_arg = FALSE;
	{
		char** arg_collection;
		int arg_collection_length1;
		int arg_it;
		arg_collection = args;
		arg_collection_length1 = args_length1;
		for (arg_it = 0; arg_it < args_length1; arg_it = arg_it + 1) {
			const char* arg;
			arg = arg_collection[arg_it];
			{
				if (!first_arg) {
					first_arg = TRUE;
					continue;
				}
				{
					if (g == NULL) {
						DesktopAgnosticVFSGlob* _tmp0_;
						DesktopAgnosticVFSGlob* _tmp1_;
						_tmp0_ = desktop_agnostic_vfs_glob_execute (arg, &_inner_error_);
						if (_inner_error_ != NULL) {
							if (_inner_error_->domain == DESKTOP_AGNOSTIC_VFS_GLOB_ERROR) {
								goto __catch0_desktop_agnostic_vfs_glob_error;
							}
							_g_object_unref0 (g);
							g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return 0;
						}
						g = (_tmp1_ = _tmp0_, _g_object_unref0 (g), _tmp1_);
					} else {
						desktop_agnostic_vfs_glob_append (g, arg, &_inner_error_);
						if (_inner_error_ != NULL) {
							if (_inner_error_->domain == DESKTOP_AGNOSTIC_VFS_GLOB_ERROR) {
								goto __catch0_desktop_agnostic_vfs_glob_error;
							}
							_g_object_unref0 (g);
							g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return 0;
						}
					}
					{
						gint _tmp2_;
						char** path_collection;
						int path_collection_length1;
						int path_it;
						path_collection = desktop_agnostic_vfs_glob_get_paths (g, &_tmp2_);
						path_collection_length1 = _tmp2_;
						for (path_it = 0; path_it < _tmp2_; path_it = path_it + 1) {
							const char* path;
							path = path_collection[path_it];
							{
								fprintf (stdout, "%s\n", path);
							}
						}
					}
				}
				goto __finally0;
				__catch0_desktop_agnostic_vfs_glob_error:
				{
					GError * err;
					err = _inner_error_;
					_inner_error_ = NULL;
					{
						if (g_error_matches (err, DESKTOP_AGNOSTIC_VFS_GLOB_ERROR, DESKTOP_AGNOSTIC_VFS_GLOB_ERROR_NOMATCH)) {
							g_critical ("test-vfs-glob.vala:60: Error: %s", err->message);
							result = 1;
							_g_error_free0 (err);
							_g_object_unref0 (g);
							return result;
						}
						_g_error_free0 (err);
					}
				}
				__finally0:
				if (_inner_error_ != NULL) {
					_g_object_unref0 (g);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return 0;
				}
			}
		}
	}
	result = 0;
	_g_object_unref0 (g);
	return result;
}


int main (int argc, char ** argv) {
	g_type_init ();
	return _vala_main (argv, argc);
}




